# 栅栏(CyclicBarrier) ——清单5-8

程序清单5-8模拟士兵参与打靶射击，所有士兵被分为一个连队(company)，一个连队中有若干排。每次只有一排士兵进行射击，每排的士兵都需要同时开始射击，且他们必须等待同排的所有士兵射击完成后才能一起撤离。交替训练，直到射击时间结束。

## CyclicBarrier

使用 **CyclicBarrier** 实现等待的线程被称为**参与方**，通过执行方法 **await()** 实现等待。

### 基本实现逻辑

**CyclicBarrier** 内部维护一个显示锁，使其可以分辨出最后一个执行 **await()** 方法的线程，该线程被称为最后一个线程。除了最后一个线程外，任何参与方执行 **await()** 方法都会导致线程生命周期变为 **WAITING** 。最后一个线程执行 **await()** 方法会使相应实例的参与方被唤醒，且当前线程不会暂停。

与 **CountDownLatch** 不同的是，**CyclicBarrier** 的实例是可以重复使用的。

### 一些TIPS

* **CyclicBarrier** 内部是基于条件变量的，其开销与条件变量的开销类似，主要是上下文切换；
* 设  **cb** 是 **CyclicBarrier** 的实例，任意一个参与方在执行 **cb.await()** 前所有的操作都是对 **barrierAction.run()** 可见的、有序的。同样的 **barrierAction.run()** 中执行的任何操作对所有参与方在 **cb.await()** 调用成功返回之后的代码是可见的，有序的。

### 典型应用场景

* 迭代算法(Interative)算法并发化。在并发化的迭代算法中，迭代操作是由多个工作线程并发执行的。**CyclicBarrier** 可用来实现执行迭代操作的任何一个工作线程必须等待其他工作线程也完成当前迭代操作的情况下，才继续下一轮迭代操作，以使上一轮结果作为下一轮的输入。
* 在测试代码中模拟高并发。

关于CyclicBarrier的滥用